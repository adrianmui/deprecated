---
layout: post
title:  "Week 6 DP Algorithm: Pascal's Triangle"
date:   2016-08-08 00:45:00 -0400
categories: vcs
---

Given numRows, generate the first numRows of Pascal's Triangle

```
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

```

Write a function that prints out the first numRows rows of Pascal's Triangle. Assume numRows will always be a natural number.


```python
require 'pry'
```

```ruby
  def generate(num_rows)
    return [1] if num_rows == 1
    arr = [1,1]
    tot_arr = [[1], arr]
    
    
    (num_rows -2).times do
      temp_arr = [1]
      arr[1..-1].each_index do |i|
        temp_arr << arr[i] + arr[i+1]
      end
    
      temp_arr << 1
      
      arr = temp_arr
      tot_arr << arr
    end
    
    tot_arr
  end
```

This solution is in O(n^2).

# puts Benchmark.measure {generate(1000)}

def fact(n)
  (1..n).reduce(:*)
end

# binomial theorem, n choose k
def binomial(n,k)
  return 1 if n-k <= 0
  return 1 if k <= 0
  fact(n) / ( fact(k) * fact( n - k ) )
end

def triangle(nth_line)
  (0..nth_line).map { |e| binomial(nth_line, e) }
end

# puts Benchmark.measure {triangle(1000)}

def next_row(row) ([0] + row).zip(row + [0]).collect {|l,r| l + r } end
 
def ros_pascal(n) n.times.inject([1]) {|x,_| next_row x } end

# puts Benchmark.measure { ros_pascal_script }


```ruby
Benchmark.bm(100) do |x|
  x.report("Adrian's way-----------:")   { generate(1000) }
  x.report("Using Binomial Theorem-:") { triangle(1000) }
  x.report("Rosetta's way----------:")  { ros_pascal(1000) }
end

       user     system      total        real
Adrian's way-----------:  0.240000   0.010000   0.250000 (  0.258908)
Using Binomial Theorem-:  1.270000   0.090000   1.360000 (  1.354088)
Rosetta's way----------:  0.260000   0.010000   0.270000 (  0.278672)

```

