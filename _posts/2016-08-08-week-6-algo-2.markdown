---
layout: post
title:  "Week 6 DP Algorithm: Pascal's Triangle"
date:   2016-08-09 00:45:00 -0400
categories: vcs
---

Given numRows, generate the first numRows of Pascal's Triangle

```
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

```

Write a function that prints out the first numRows rows of Pascal's Triangle. Assume numRows will always be a natural number.


```ruby
require 'benchmark'
require 'pry'

def generate(num_rows)
  return [1] if num_rows == 1
  arr = [1,1]
  tot_arr = [[1], arr]

  (num_rows -2).times do
    temp_arr = [1]
    arr[1..-1].each_index do |i|
      temp_arr << arr[i] + arr[i+1]
    end
  
    temp_arr << 1
    
    arr = temp_arr
    tot_arr << arr
  end
  tot_arr
end

puts Benchmark.measure {generate(1000)}
```

This solution is in O(n^2).



```ruby
def fact(n)
  (1..n).reduce(:*)
end

# binomial theorem, n choose k
def binomial(n,k)
  return 1 if n-k <= 0
  return 1 if k <= 0
  fact(n) / ( fact(k) * fact( n - k ) )
end

def triangle(nth_line)
  (0..nth_line).map { |e| binomial(nth_line, e) }
end

# puts Benchmark.measure {triangle(1000)}
```


```ruby
def next_row(row) ([0] + row).zip(row + [0]).collect {|l,r| l + r } end
 
def ros_pascal(n) n.times.inject([1]) {|x,_| next_row x } end

# puts Benchmark.measure { ros_pascal_script }
```


```ruby
Benchmark.bm(100) do |x|
  x.report("Adrian's way-----------:")   { generate(1000) }
  x.report("Using Binomial Theorem-:") { triangle(1000) }
  x.report("Rosetta's way----------:")  { ros_pascal(1000) }
end

       user     system      total        real
Adrian's way-----------:  0.240000   0.010000   0.250000 (  0.258908)
Using Binomial Theorem-:  1.270000   0.090000   1.360000 (  1.354088)
Rosetta's way----------:  0.260000   0.010000   0.270000 (  0.278672)

```

